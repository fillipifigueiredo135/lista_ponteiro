Nome: <Fillipi Candido> / <Maria Estefsnny>
Matricula: <20230073195> / <202300887575> 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 1:

◦ p == &i;
Verifica se p está apontando para o endereço de i
◦ *p - *q;
Subtrai os valores armazenados nos ponteiros
◦ **&p;
&p obtém o endereço de memória do ponteiro p.
  com (*) desreferencia esse endereço, o que significa que estamos acessando o
valor apontado pelo ponteiro p
(endereço de memória de i), o valor de *p será o valor de i, que é 3.
  Por fim, (*) desreferência novamente, o que significa que estamos acessando
o valor apontado por *p, ou seja, o valor de i.
◦ 3 - *p/(*q) + 7;
(Está realizando a equação:
 3 - [elemento de P]/[elemento de Q] + 7
3 - 0 +7 = 10)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 2:

main(){
  int i=5, *p;
  p = &i;
  printf("%p %p %d %d %d %d\n", p, p+1, *p+2, **&p, 3**p, **&p+4);
}
p = onde o ponteiro armazena dados. de acordo com a questão (4094) 
p+1 = local de armazenamento do ponteiro com um acréscimo de
(de acordo com a questão) 2 bytes. (4096) supostamente
*p+2 = Elemento armazenado no ponteiro (i [i=5]) + 2, resultando em 7.
**&p = uma forma diferente de expressar o valor apontado por *p (5)
3**p = 3 multiplicando o elemento de p (15)
**&p+4 = o elemento de p somado a 4 (9)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 3:

◦ *q = &j;
Ilegal. Isso ocorre porque *q é um valor inteiro (devido à sua declaração como int *q), 
e você está tentando atribuir a ele o endereço de j, o que resulta em um tipo incompatível.
◦ i = (*&)j;
Ilegal. A expressão (*&)j não tem um significado válido em C, pois você está tentando 
desreferenciar o endereço de j, o que não faz sentido.
◦ q = *p;
Ilegal. Você está tentando atribuir a um ponteiro (q) o valor inteiro apontado
por outro ponteiro (p), o que não é permitido em C sem uma conversão explícita.
◦ i = (*p)++ + *q;
Ilegal. Isso ocorre porque (*p)++ é um operador inválido para um ponteiro e 
*q também está tentando desreferenciar um ponteiro sem que ele esteja
apontando para algo válido. Além disso, a expressão não está claramente
definida em termos de comportamento definido em C.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 4:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 5:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 6:

 resposta: *(pulo + 2); (valor do terceiro elemento do vetor)
 resto:
[*(pulo + 4); (quinto elemento do vetor)]
[pulo + 4; (quinto endereço de memória)]
[pulo + 2; (terceiro endereço de memória do ponteiro)]
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 7:

todas validas
p = mat + 1; (atribui ao ponteiro p o endereço do segundo elemento do vetor mat)
p = mat; (atribui ao ponteiro p o endereço do primeiro elemento do vetor mat)
x = (mat); (atribui à variável x o valor do *primeiro elemento do vetor mat)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 8:

Este programa C também cria uma matriz chamada vet que tem três elementos: 4, 9 e 13. 
Subsequentemente, ele repeti esse array com um loop for, mais em vez de imprimir os 
valores dos elementos do array, ele usa a função printf() com o formato %X para imprimir
os endereços de memória dos elementos em hexadecimal. O endereço de memória do elemento I
no vet de matriz é representado pelo símbolo vet+i. Como resultado, o programa imprimirá
os endereços de memória dos elementos da matriz em hexadecimal.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 9:

Este software contém alguns erros sintáticos e lógicos.
1 Não é possível iniciar membros de uma estrutura dentro de sua definição em C.
2.Foi declarado um ponteiro para a estrutura struct teste, 
mais não alocou memória para ela, antes de acessar seuss membros. 
Isso resultará em um comportamento mal definido.
3. tentando acessar s->name, mas é nome, não name, o membro da estrutura. 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 10:

O código fornecido tem um erro. 
Você está tentando modificar um valor constante, 
o que resultará em um erro de compilação.
A modificação a um valor constante sem atribuir um 
endereço de memória válido, impossibilita o uso do codigo.
um modo de corrigir o código seria essa alteração:

#include <stdio.h>

int main() {
    int const x = (int)malloc(sizeof(int));
    *x = 3;
    printf("%d", ++(*x));
    free((int*)x);
    return 0;
}
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 11:

•Se x for declarado como (char x[4]), 
então cada elemento ocupará 1 byte de memória.

•Se x for declarado como (int x[4]), 
então cada elemento ocupará 2 bytes de memória
(em sistemas típicos de 32 bits) ou 4 bytes de
memória (em sistemas típicos de 64 bits).

•Se x for declarado como floats (float x[4]), 
cada elemento ocupará 4 bytes de memória.

•Se x for declarado como (double x[4]), cada
elemento ocupará 8 bytes de memória.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 12:

Comandos válidos:

1. aloha[2] = value;: Atribui o valor da variável `value`
à terceira posição do array `aloha`.
2. coisas[4][4] = aloha[3];`: Atribui o valor do quarto 
elemento do array `aloha` à posição `[4][4]` do array `coisas`.
3. `pf = &value;`: Atribui o endereço de `value` ao ponteiro `pf`.
4. `pf = &aloha[0];`: Atribui o endereço do primeiro elemento
do array `aloha` ao ponteiro `pf`.

Comandos Inválidos:

1. `scanf("%f", &aloha);`: Não é válido porque `scanf` espera
um ponteiro para o primeiro elemento do array, não para o array inteiro.
2. `aloha = "value";`: Não é válido porque está tentando atribuir uma 
string a um array de floats.
3. `printf("%f", aloha);`: Não é válido porque `printf` espera um valor 
float, não um array de floats.
4. `coisas[5] = aloha;`: Não é válido porque você não pode atribuir um 
array inteiro a uma posição de um array multidimensional.
5. `pf = value;`: Não é válido porque `pf` é um ponteiro para float, e 
`value` é um float. Para atribuir o endereço de `value` a `pf`, usamos `pf = &value;`.
6. `pf = aloha;`: Não é válido porque `pf` é um ponteiro para float, mas
`aloha` é um array de floats. Para fazer isso, usamos `pf = &aloha[0];` para apontar
para o primeiro elemento de `aloha`.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 13:

Memory leak refere-se a um erro de programação
em que uma aplicação aloca dinamicamente e falha em liberá-la
quando não é mais necessária. O programa pode usar memoria excessiva
com o tempo, podendo levar um mal desempenho através de falhas e 
até mesmo travamento do sistema , devido à falta de memória disponível.

A seguir está três exemplos de programas em C que apresenta 
memory leaks:

Exemplo 1:

#include <stdlib.h>

int main() {
    while(1) {
        int *ptr = (int *)malloc(100 * sizeof(int));
        // Não há chamada para free(ptr), então a 
memória alocada nunca é liberada
    }
    return 0;
}

Neste exemplo, o programa entra em um loop infinito onde
aloca dinamicamente memória para um array de inteiros, 
mas nunca libera essa memória. 
Isso resulta em um vazamento de memória contínuo.

Exemplo 2:
#include <stdlib.h>

int main() {
    int *ptr = (int *)malloc(100 * sizeof(int));
    ptr = NULL; // Perde a referência para 
a memória alocada, impossibilitando a sua liberação
    return 0;
}
Neste caso, a memória é alocada dinamicamente,
mas a única referência para ela é perdida quando ptr 
é definido como NULL. Como resultado, não há maneira
de acessar essa memória para liberá-la mais tarde,
causando um vazamento de memória.

Exemplo 3:#include <stdlib.h>

int main() {
    int *ptr1 = (int *)malloc(100 * sizeof(int));
    int *ptr2 = (int *)malloc(100 * sizeof(int));
    ptr1 = ptr2; // ptr1 agora aponta para a mesma memória que ptr2
    free(ptr1); // Libera a memória apontada por ptr2, mas não a
memória originalmente alocada para ptr1
    return 0;
}Neste exemplo, embora a memória alocada para ptr1 seja liberada, 
a memória alocada originalmente para ptr1 é perdida, pois agora ptr1 e
ptr2 apontam para a mesma região de memória. Isso resulta em um vazamento
de memória da alocação original de ptr1.

Tendo em vista que, os exemplos acima, por falta de uma chamada 
da função free(), resulta em uma repetitiva alocação de memória 
sem liberação. Ocasionando um memory leak.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 14:

Um ponteiro para uma função é um tipo de variável 
que armazena o endereço de memória de uma função. Isso permite que a função 
seja referenciada e invocada indiretamente através do ponteiro.

Aqui está um exemplo em C que demonstra o uso de um ponteiro para uma função:

```c
#include <stdio.h>

// Função de soma
int soma(int a, int b) {
    return a + b;
}

// Função de subtração
int subtracao(int a, int b) {
    return a - b;
}

int main() {
    int (*funcao)(int, int); // Declaração de um ponteiro para função

    // Atribuição do endereço da função soma ao ponteiro
    funcao = soma;
    printf("Resultado da soma: %d\n", funcao(5, 3)); // Chamada indireta da função soma

    // Atribuição do endereço da função subtracao ao ponteiro
    funcao = subtracao;
    printf("Resultado da subtracao: %d\n", funcao(5, 3)); // Chamada indireta da função subtracao

    return 0;
}
```

Como o programa funciona:

1. `#include <stdio.h>`: Inclui a biblioteca padrão de entrada 
e saída em C para usar as funções de entrada/saída padrão.
2. `int soma(int a, int b)`: Define uma função chamada `soma` 
que retorna a soma de dois inteiros.
3. `int subtracao(int a, int b)`: Define uma função chamada 
`subtracao` que retorna a subtração de dois inteiros.
4. `int (*funcao)(int, int);`: Declara um ponteiro para função 
chamado `funcao` que aceita dois inteiros como argumentos e retorna um inteiro.
5. `funcao = soma;`: Atribui o endereço da função `soma` ao ponteiro `funcao`.
6. `printf("Resultado da soma: %d\n", funcao(5, 3));`: Invoca a função
`soma` indiretamente através do ponteiro `funcao` e imprime o resultado.
7. `funcao = subtracao;`: Atribui o endereço da função `subtracao` ao ponteiro `funcao`.
8. `printf("Resultado da subtracao: %d\n", funcao(5, 3));`: Invoca a função 
`subtracao` indiretamente através do ponteiro `funcao` e imprime o resultado.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 15:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 16:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 17:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 18:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 19:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 20:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 21:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 22:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 23:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 24:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 25:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
