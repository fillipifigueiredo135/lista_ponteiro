Nome: <Fillipi Candido> / <Maria Estefsnny>
Matricula: <20230073195> / <202300887575> 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 1:

◦ p == &i;
Verifica se p está apontando para o endereço de i
◦ *p - *q;
Subtrai os valores armazenados nos ponteiros
◦ **&p;
&p obtém o endereço de memória do ponteiro p.
  com (*) desreferencia esse endereço, o que significa que estamos acessando o valor apontado pelo ponteiro p
(endereço de memória de i), o valor de *p será o valor de i, que é 3.
  Por fim, (*) desreferência novamente, o que significa que estamos acessando o valor apontado por *p, ou seja, o valor de i.
◦ 3 - *p/(*q) + 7;
(Está realizando a equação:
 3 - [elemento de P]/[elemento de Q] + 7
3 - 0 +7 = 10)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 2:

main(){
  int i=5, *p;
  p = &i;
  printf("%p %p %d %d %d %d\n", p, p+1, *p+2, **&p, 3**p, **&p+4);
}
p = onde o ponteiro armazena dados. de acordo com a questão (4094) 
p+1 = local de armazenamento do ponteiro com um acréscimo de (de acordo com a questão) 2 bytes. (4096) supostamente
*p+2 = Elemento armazenado no ponteiro (i [i=5]) + 2, resultando em 7.
**&p = uma forma diferente de expressar o valor apontado por *p (5)
3**p = 3 multiplicando o elemento de p (15)
**&p+4 = o elemento de p somado a 4 (9)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 3:

◦ *q = &j;
Ilegal. Isso ocorre porque *q é um valor inteiro (devido à sua declaração como int *q), e você está tentando atribuir a ele o endereço de j, o que resulta em um tipo incompatível.
◦ i = (*&)j;
Ilegal. A expressão (*&)j não tem um significado válido em C, pois você está tentando desreferenciar o endereço de j, o que não faz sentido.
◦ q = *p;
Ilegal. Você está tentando atribuir a um ponteiro (q) o valor inteiro apontado por outro ponteiro (p), o que não é permitido em C sem uma conversão explícita.
◦ i = (*p)++ + *q;
Ilegal. Isso ocorre porque (*p)++ é um operador inválido para um ponteiro e *q também está tentando desreferenciar um ponteiro sem que ele esteja apontando para algo válido. Além disso, a expressão não está claramente definida em termos de comportamento definido em C.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 4:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 5:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 6:

 resposta: *(pulo + 2); (valor do terceiro elemento do vetor)
 resto:
[*(pulo + 4); (quinto elemento do vetor)]
[pulo + 4; (quinto endereço de memória)]
[pulo + 2; (terceiro endereço de memória do ponteiro)]
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 7:

todas validas
p = mat + 1; (atribui ao ponteiro p o endereço do segundo elemento do vetor mat)
p = mat; (atribui ao ponteiro p o endereço do primeiro elemento do vetor mat)
x = (mat); (atribui à variável x o valor do *primeiro elemento do vetor mat)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 8:

Este programa C também cria uma matriz chamada vet que tem três elementos: 4, 9 e 13. 
Subsequentemente, ele repeti esse array com um loop for, mais em vez de imprimir os 
valores dos elementos do array, ele usa a função printf() com o formato %X para imprimir
os endereços de memória dos elementos em hexadecimal. O endereço de memória do elemento I
no vet de matriz é representado pelo símbolo vet+i. Como resultado, o programa imprimirá
os endereços de memória dos elementos da matriz em hexadecimal.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 9:

Este software contém alguns erros sintáticos e lógicos.
1 Não é possível iniciar membros de uma estrutura dentro de sua definição em C.
2.Foi declarado um ponteiro para a estrutura struct teste, 
mais não alocou memória para ela, antes de acessar seuss membros. Isso resultará em um comportamento mal definido.
3. tentando acessar s->name, mas é nome, não name, o membro da estrutura. 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 10:

O código fornecido tem um erro. 
Você está tentando modificar um valor constante, 
o que resultará em um erro de compilação.
A modificação a um valor constante sem atribuir um endereço de memória válido, impossibilita o uso do codigo.
um modo de corrigir o código seria essa alteração:

#include <stdio.h>

int main() {
    int const x = (int)malloc(sizeof(int));
    *x = 3;
    printf("%d", ++(*x));
    free((int*)x);
    return 0;
}
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 11:



- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 12:

Comandos válidos:

1. aloha[2] = value;: Atribui o valor da variável `value`
à terceira posição do array `aloha`.
2. coisas[4][4] = aloha[3];`: Atribui o valor do quarto 
elemento do array `aloha` à posição `[4][4]` do array `coisas`.
3. `pf = &value;`: Atribui o endereço de `value` ao ponteiro `pf`.
4. `pf = &aloha[0];`: Atribui o endereço do primeiro elemento
do array `aloha` ao ponteiro `pf`.

Comandos Inválidos:

1. `scanf("%f", &aloha);`: Não é válido porque `scanf` espera
um ponteiro para o primeiro elemento do array, não para o array inteiro.
2. `aloha = "value";`: Não é válido porque está tentando atribuir uma 
string a um array de floats.
3. `printf("%f", aloha);`: Não é válido porque `printf` espera um valor 
float, não um array de floats.
4. `coisas[5] = aloha;`: Não é válido porque você não pode atribuir um 
array inteiro a uma posição de um array multidimensional.
5. `pf = value;`: Não é válido porque `pf` é um ponteiro para float, e 
`value` é um float. Para atribuir o endereço de `value` a `pf`, usamos `pf = &value;`.
6. `pf = aloha;`: Não é válido porque `pf` é um ponteiro para float, mas
`aloha` é um array de floats. Para fazer isso, usamos `pf = &aloha[0];` para apontar
para o primeiro elemento de `aloha`.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 13:

Memory leak refere-se a um erro de programação
em que uma aplicação aloca dinamicamente e falha em liberá-la
quando não é mais necessária. O programa pode usar memoria excessiva
com o tempo, podendo levar um mal desempenho através de falhas e 
até mesmo travamento do sistema , devido à falta de memória disponível.

A seguir está três exemplos de programas em C que apresenta 
memory leaks:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 14:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 15:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 16:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 17:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 18:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 19:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 20:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 21:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 22:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 23:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 24:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Questão 25:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
